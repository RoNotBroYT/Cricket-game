<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cricket Bat Demo</title>
  <style>
    body { background: #222; color: #eee; margin: 0; }
    .container { display: flex; flex-direction: column; align-items: center; }
    canvas { background: #103; margin-top: 30px; border-radius: 20px; }
    .info { color: #fff; font-size: 1.1em; margin: 10px 0; }
    button { margin-bottom: 10px; }
  </style>
</head>
<body>
<div class="container">
  <h2>Cricket Bat/Collision Demo</h2>
  <div class="info" id="scoreInfo">Score: 0</div>
  <button onclick="resetGame()">Restart</button>
  <canvas id="game" width="720" height="480"></canvas>
</div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreInfo = document.getElementById("scoreInfo");

const BAT_X = 630, BAT_Y = 240;
const BAT_W = 10, BAT_H = 64;
const BALL_RADIUS = 9;
const BALL_START_X = 100, BALL_START_Y = 240;
const PITCH_Y = 160, PITCH_H = 160;

let score = 0;
let batAngle = 0;
let swinging = false;
let swingFrame = 0;
let ball, ballMoving = false, ballHit = false;
let animFrame;

function resetGame() {
  score = 0;
  batAngle = 0;
  swinging = false;
  swingFrame = 0;
  resetBall();
  updateScore();
  cancelAnimationFrame(animFrame);
  draw();
}

function resetBall() {
  ball = {
    x: BALL_START_X,
    y: BALL_START_Y,
    vx: 7,
    vy: 0,
    radius: BALL_RADIUS,
    hit: false
  };
  ballMoving = true;
  ballHit = false;
}

function updateScore() {
  scoreInfo.textContent = "Score: " + score;
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Pitch
  ctx.save();
  ctx.fillStyle = "#fee";
  ctx.fillRect(60, PITCH_Y, 620, PITCH_H);
  ctx.restore();

  // Batsman
  ctx.save();
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(BAT_X-36, BAT_Y-30, 13, 0, Math.PI*2); // head
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(BAT_X-36, BAT_Y-17);
  ctx.lineTo(BAT_X-36, BAT_Y+26);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(BAT_X-36, BAT_Y+7);
  ctx.lineTo(BAT_X-54, BAT_Y+26);
  ctx.moveTo(BAT_X-36, BAT_Y+7);
  ctx.lineTo(BAT_X-18, BAT_Y+26);
  ctx.stroke();
  ctx.restore();

  // Bat
  ctx.save();
  ctx.translate(BAT_X, BAT_Y);
  ctx.rotate(batAngle);
  ctx.fillStyle = "#ebc154";
  ctx.fillRect(-BAT_W/2, -BAT_H, BAT_W, BAT_H);
  ctx.restore();

  // Ball
  ctx.save();
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, 2 * Math.PI);
  ctx.fillStyle = ball.hit ? "#9f0" : "#f11";
  ctx.fill();
  ctx.restore();

  if (ballMoving) update();

  animFrame = requestAnimationFrame(draw);
}

function swingBat() {
  if (swinging) return;
  swinging = true;
  swingFrame = 0;
  function animateSwing() {
    swingFrame++;
    // A quick swing arc, forward then snap back
    if (swingFrame <= 7) {
      batAngle = -Math.PI/3 * Math.sin(Math.PI * swingFrame / 14);
      requestAnimationFrame(animateSwing);
    } else {
      batAngle = 0;
      swinging = false;
    }
  }
  animateSwing();
}

function update() {
  if (!ballMoving) return;
  // Save previous position for continuous collision detection
  let prevX = ball.x, prevY = ball.y;

  ball.x += ball.vx;
  ball.y += ball.vy;

  // Bat collision detection - continuous along travel path
  if (!ball.hit && batCollide(prevX, prevY, ball.x, ball.y)) {
    ball.hit = true;
    ballHit = true;
    ball.vx = 6 + Math.random()*6;
    ball.vy = (Math.random()-0.5)*5;
    score += 4;
    updateScore();
  }

  // Out of bounds
  if (ball.x > canvas.width+50 || ball.x < -50 || ball.y < -50 || ball.y > canvas.height+50) {
    resetBall();
  }
}

function batCollide(px, py, x, y) {
  // Bat is a long rectangle, possibly rotated, at (BAT_X, BAT_Y) angle batAngle, length BAT_H
  // We'll check the closest point on the ball path segment to the bat's line segment
  // Bat line: from (BAT_X, BAT_Y) to (BAT_X + sin(angle)*(-BAT_H), BAT_Y - cos(angle)*BAT_H)
  let bx1 = BAT_X, by1 = BAT_Y;
  let bx2 = BAT_X + Math.sin(batAngle)*(-BAT_H), by2 = BAT_Y - Math.cos(batAngle)*BAT_H;

  // For the ball's trajectory segment, check the closest approach to the bat's segment
  // We'll discretize for safety (every 2 px)
  let steps = Math.ceil(Math.hypot(x-px, y-py)/2);
  for (let i=0; i<=steps; ++i) {
    let bx = px + (x-px)*i/steps;
    let by = py + (y-py)*i/steps;
    // distance from (bx,by) to bat segment
    let d = pointToSegmentDist(bx,by, bx1,by1, bx2,by2);
    if (d < BALL_RADIUS + BAT_W/2) return true;
  }
  return false;
}

function pointToSegmentDist(px,py, x1,y1, x2,y2) {
  // Returns the distance from point (px,py) to segment (x1,y1)-(x2,y2)
  let A = px - x1;
  let B = py - y1;
  let C = x2 - x1;
  let D = y2 - y1;

  let dot = A * C + B * D;
  let len_sq = C * C + D * D;
  let param = -1;
  if (len_sq !== 0) param = dot / len_sq;

  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }

  let dx = px - xx;
  let dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

canvas.addEventListener("click", swingBat);
window.addEventListener("keydown", e => { if (e.code === "Space") swingBat(); });
resetGame();
</script>
</body>
</html>
