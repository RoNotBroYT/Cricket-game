<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cricket Doodle Style - Smooth Running</title>
  <style>
    body { margin:0; background: #0c2e12; }
    .container { display: flex; flex-direction: column; align-items: center; }
    canvas { background: #183920; border-radius: 16px; margin: 30px 0; }
    .info { color: #fff; font-size: 1.1em; margin: 10px 0; }
    button { margin: 10px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Cricket Google Doodle Style Demo</h2>
    <div class="info" id="scoreInfo">Score: 0</div>
    <button onclick="resetGame()">Restart</button>
    <canvas id="game" width="800" height="400"></canvas>
  </div>
  <script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreInfo = document.getElementById("scoreInfo");

const BAT_X = 750, BAT_Y = 200;
const BAT_W = 10, BAT_H = 60;
const BALL_RADIUS = 8;
const BALL_START_X = 70, BALL_START_Y = 200;
const STUMP_X = 780, STUMP_Y = 200;
const PITCH_X1 = 100, PITCH_X2 = 750;
const PITCH_Y = 110, PITCH_H = 180;

const RUN_DISTANCE = PITCH_X2 - PITCH_X1 - 25; // length the batsmen run

let score = 0, running = false, runCount = 0;
let batAngle = 0, swinging = false, swingFrame = 0;
let ball, ballMoving = false, ballHit = false, ballOutcome = '';
let batsmen = [
  {x: BAT_X-25, y: BAT_Y+35, target: BAT_X-25, base: BAT_X-25},
  {x: PITCH_X1, y: BALL_START_Y+35, target: PITCH_X1, base: PITCH_X1}
];
let fielders = [], fielder, fielderHasBall = false, fielderThrowing = false, fieldBallX = 0, fieldBallY = 0;
let animFrame, runAnim = 0, lastCross = false;

function resetGame() {
  score = 0;
  batAngle = 0;
  swinging = false;
  swingFrame = 0;
  runCount = 0;
  running = false;
  batsmen[0].x = BAT_X-25;
  batsmen[1].x = PITCH_X1;
  batsmen[0].target = batsmen[0].base = BAT_X-25;
  batsmen[1].target = batsmen[1].base = PITCH_X1;
  resetBall();
  // Place fielders at fixed positions
  fielders = [
    {x: 400, y: 120, homeX: 400, homeY: 120},
    {x: 400, y: 320, homeX: 400, homeY: 320}
  ];
  fielder = null;
  fielderHasBall = false;
  fielderThrowing = false;
  updateScore();
  cancelAnimationFrame(animFrame);
  draw();
}

function resetBall() {
  ball = {
    x: BALL_START_X,
    y: BALL_START_Y,
    vx: 6,
    vy: 0,
    radius: BALL_RADIUS,
    hit: false,
    inPlay: false,
    outcome: '',
    progress: 0
  };
  ballMoving = true;
  ballHit = false;
  ballOutcome = '';
  running = false;
  runCount = 0;
  batsmen[0].x = BAT_X-25;
  batsmen[1].x = PITCH_X1;
  batsmen[0].target = batsmen[0].base = BAT_X-25;
  batsmen[1].target = batsmen[1].base = PITCH_X1;
  lastCross = false;
}

function updateScore() {
  scoreInfo.textContent = "Score: " + score;
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Pitch
  ctx.save();
  ctx.fillStyle = "#f3eaae";
  ctx.fillRect(PITCH_X1, PITCH_Y, PITCH_X2-PITCH_X1, PITCH_H);
  ctx.restore();

  // Stumps
  ctx.save();
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 4;
  for(let i=0;i<3;i++) {
    ctx.beginPath();
    ctx.moveTo(STUMP_X+i*6,STUMP_Y-25);
    ctx.lineTo(STUMP_X+i*6,STUMP_Y+25);
    ctx.stroke();
  }
  ctx.restore();

  // Fielders (always shown)
  for(const fld of fielders) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(fld.x, fld.y, 17, 0, Math.PI*2);
    ctx.fillStyle = "#0af";
    ctx.fill();
    ctx.beginPath();
    ctx.arc(fld.x, fld.y-15, 7, 0, Math.PI*2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.restore();
  }

  // Batsmen
  for(const b of batsmen) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(b.x, b.y-20, 11, 0, Math.PI*2);
    ctx.fillStyle = "#ffe100";
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(b.x, b.y-9);
    ctx.lineTo(b.x, b.y+20);
    ctx.stroke();
    ctx.restore();
  }

  // Bat
  ctx.save();
  ctx.translate(BAT_X, BAT_Y);
  ctx.rotate(batAngle);
  ctx.fillStyle = "#ebc154";
  ctx.fillRect(-BAT_W/2, -BAT_H, BAT_W, BAT_H);
  ctx.restore();

  // Ball
  ctx.save();
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, 2 * Math.PI);
  ctx.fillStyle = ball.hit ? "#9f0" : "#f11";
  ctx.fill();
  ctx.restore();

  // Fielder throw-ball animation (draw over everything)
  if (fielderThrowing) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(fieldBallX, fieldBallY, BALL_RADIUS, 0, 2*Math.PI);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.restore();
  }

  // Running indicator
  if (running) {
    ctx.save();
    ctx.font = "bold 22px Segoe UI";
    ctx.fillStyle = "#ffe100";
    ctx.fillText("RUNNING...", 340, 50);
    ctx.restore();
  }

  if (ballMoving) update();

  animFrame = requestAnimationFrame(draw);
}

function swingBat() {
  if (swinging || ball.hit) return;
  swinging = true;
  swingFrame = 0;
  function animateSwing() {
    swingFrame++;
    if (swingFrame <= 7) {
      batAngle = -Math.PI/2 * Math.sin(Math.PI * swingFrame / 14);
      requestAnimationFrame(animateSwing);
    } else {
      batAngle = 0;
      swinging = false;
    }
  }
  animateSwing();
}

function update() {
  // Save previous position for collision detection
  let prevX = ball.x, prevY = ball.y;

  // Ball moves
  if (!ball.hit) {
    ball.x += ball.vx;
    ball.y += ball.vy;
    // Bat collision detection
    if (batCollide(prevX, prevY, ball.x, ball.y) && swinging) {
      ball.hit = true;
      // Outcome: random-ish
      let timing = Math.abs(ball.y - BAT_Y);
      let rand = Math.random();
      if (timing < 16 && rand > 0.65) {
        ball.outcome = "6";
        ballOutcome = "SIX!";
        ball.vx = 13; ball.vy = (Math.random()-0.5)*2;
        ball.progress = 0;
      } else if (timing < 24 && rand > 0.3) {
        ball.outcome = "4";
        ballOutcome = "FOUR!";
        ball.vx = 9; ball.vy = (Math.random()-0.5)*5;
        ball.progress = 0;
      } else if (timing < 34) {
        ball.outcome = "run";
        ballOutcome = "Run!";
        ball.vx = 6; ball.vy = (Math.random()-0.5)*8;
        ball.progress = 0;
      } else {
        ball.outcome = "caught";
        ballOutcome = "Caught!";
        ball.vx = 6; ball.vy = -10;
      }
    }
    // Missed
    if (ball.x > BAT_X+30 && !ball.hit) {
      ballMoving = false;
      setTimeout(resetBall, 1200);
    }
  } else {
    // After hit
    if (ball.outcome == "6") {
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.progress += Math.abs(ball.vx);
      if (ball.x > 820 || ball.progress > 550) {
        score += 6;
        updateScore();
        ballMoving = false;
        setTimeout(resetBall, 1200);
      }
    } else if (ball.outcome == "4") {
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.progress += Math.abs(ball.vx);
      if (ball.x > 820 || ball.progress > 460) {
        score += 4;
        updateScore();
        ballMoving = false;
        setTimeout(resetBall, 1200);
      }
    } else if (ball.outcome == "run") {
      // Fielder runs to ball
      if (!fielder) {
        let minDist = 9999;
        for (const f of fielders) {
          let d = Math.abs(f.x - ball.x) + Math.abs(f.y - ball.y);
          if (d < minDist) { minDist = d; fielder = f; }
        }
        fielderHasBall = false;
        fielderThrowing = false;
        fieldBallX = ball.x;
        fieldBallY = ball.y;
        running = true;
        runCount = 0;
        runAnim = 0;
        batsmen[0].target = batsmen[1].base;
        batsmen[1].target = batsmen[0].base;
        batsmen[0].base = batsmen[0].x;
        batsmen[1].base = batsmen[1].x;
        lastCross = false;
      }
      if (!fielderHasBall) {
        // Move fielder to ball
        let dx = ball.x - fielder.x, dy = ball.y - fielder.y;
        let d = Math.sqrt(dx*dx + dy*dy);
        if (d > 3) {
          fielder.x += dx/d*3.3;
          fielder.y += dy/d*3.3;
        } else {
          fielderHasBall = true;
          fielderThrowing = true;
        }
        // Ball slows
        ball.vx *= 0.96;
        ball.vy *= 0.96;
        ball.x += ball.vx;
        ball.y += ball.vy;
      } else if (fielderThrowing) {
        // Fielder throws ball to stumps
        let dx = STUMP_X - fielder.x, dy = STUMP_Y - fielder.y;
        let d = Math.sqrt(dx*dx + dy*dy);
        if (!fieldBallX) { fieldBallX = fielder.x; fieldBallY = fielder.y; }
        let tx = dx/d*9, ty = dy/d*9;
        fieldBallX += tx;
        fieldBallY += ty;
        // When reaches stumps
        if (Math.abs(fieldBallX-STUMP_X)<8 && Math.abs(fieldBallY-STUMP_Y)<8) {
          fielderThrowing = false;
          running = false;
          ballMoving = false;
          score += runCount;
          updateScore();
          setTimeout(resetBall, 1300);
          // Reset fielders to home positions
          for(const fld of fielders) {
            fld.x = fld.homeX;
            fld.y = fld.homeY;
          }
        }
      }
      // Smooth auto running batsmen
      if (running) {
        // They start at their base, run to the other's base
        let speed = 2.3;
        batsmen[0].x += Math.sign(batsmen[0].target - batsmen[0].x) * speed;
        batsmen[1].x += Math.sign(batsmen[1].target - batsmen[1].x) * speed;
        // When they pass each other, score a run (only once per cross)
        let crossing = (batsmen[0].x < batsmen[1].x+10);
        if (crossing && !lastCross) {
          runCount++;
          lastCross = true;
        }
        if (!crossing) lastCross = false;
        // When a batsman reaches the other's base, swap targets for next run
        if (Math.abs(batsmen[0].x-batsmen[0].target)<3 && Math.abs(batsmen[1].x-batsmen[1].target)<3) {
          let tmp = batsmen[0].target;
          batsmen[0].target = batsmen[1].base;
          batsmen[1].target = batsmen[0].base;
          batsmen[0].base = batsmen[0].x;
          batsmen[1].base = batsmen[1].x;
        }
      }
    } else if (ball.outcome == "caught") {
      // Caught!
      ball.y += ball.vy;
      ball.vy += 2;
      if (ball.y > 410) {
        ballMoving = false;
        setTimeout(resetBall, 1500);
      }
    }
  }
}

function batCollide(px, py, x, y) {
  // Bat is a vertical rectangle at (BAT_X, BAT_Y), angle batAngle
  // We'll check the closest point on the ball path segment to the bat's segment
  let bx1 = BAT_X, by1 = BAT_Y;
  let bx2 = BAT_X + Math.sin(batAngle)*(-BAT_H), by2 = BAT_Y - Math.cos(batAngle)*BAT_H;
  let steps = Math.ceil(Math.hypot(x-px, y-py)/2);
  for (let i=0; i<=steps; ++i) {
    let bx = px + (x-px)*i/steps;
    let by = py + (y-py)*i/steps;
    let d = pointToSegmentDist(bx,by, bx1,by1, bx2,by2);
    if (d < BALL_RADIUS + BAT_W/2) return true;
  }
  return false;
}
function pointToSegmentDist(px,py, x1,y1, x2,y2) {
  let A = px - x1;
  let B = py - y1;
  let C = x2 - x1;
  let D = y2 - y1;
  let dot = A * C + B * D;
  let len_sq = C * C + D * D;
  let param = -1;
  if (len_sq !== 0) param = dot / len_sq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  let dx = px - xx;
  let dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

canvas.addEventListener("click", swingBat);
window.addEventListener("keydown", e => { if (e.code === "Space") swingBat(); });
resetGame();
  </script>
</body>
</html>
