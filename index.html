<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> Fun Cricket Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin:0; background: #0c2e12; }
    .container { display: flex; flex-direction: column; align-items: center; }
    canvas { background: #183920; border-radius: 16px; margin: 30px 0; }
    .info { color: #fff; font-size: 1.1em; margin: 10px 0; }
    button { margin: 10px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Fun Cricket Game</h2>
    <div class="info" id="scoreInfo">Score: 0</div>
    <button onclick="resetGame()">Restart</button>
    <canvas id="game" width="900" height="440"></canvas>
  </div>
  <script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreInfo = document.getElementById("scoreInfo");

const PITCH_X1 = 130, PITCH_X2 = 770;
const PITCH_Y = 110, PITCH_H = 220;
const WICKET1_X = 130, WICKET1_Y = 220;
const WICKET2_X = 770, WICKET2_Y = 220;
const STUMP_HEIGHT = 38, STUMP_GAP = 6;
const FIELD_LEFT = 80, FIELD_TOP = 60, FIELD_RIGHT = 820, FIELD_BOTTOM = 380;

const BAT_X = WICKET2_X + 2, BAT_Y = WICKET2_Y;
const BAT_W = 8, BAT_H = 38;
const BALL_RADIUS = 8;
const BALL_START_X = WICKET1_X + 10, BALL_START_Y = WICKET1_Y;

const BATSMAN1_START = {x: BAT_X-22, y: BAT_Y+32};
const BATSMAN2_START = {x: WICKET1_X-4, y: BALL_START_Y+32};

let score = 0, running = false, runCount = 0;
let batAngle = 0, swinging = false, swingFrame = 0;
let ball, ballMoving = false, ballHit = false, ballOutcome = '';
let batsmen = [
  {x: BATSMAN1_START.x, y: BATSMAN1_START.y, target: BATSMAN1_START.x, base: BATSMAN1_START.x},
  {x: BATSMAN2_START.x, y: BATSMAN2_START.y, target: BATSMAN2_START.x, base: BATSMAN2_START.x}
];
let fielders = [], fielder, fielderHasBall = false, fielderThrowing = false, fieldBallX = 0, fieldBallY = 0;
let animFrame, lastCross = false, returningToBowler = false;

function resetGame() {
  score = 0;
  batAngle = 0;
  swinging = false;
  swingFrame = 0;
  runCount = 0;
  running = false;
  batsmen[0].x = BATSMAN1_START.x;
  batsmen[1].x = BATSMAN2_START.x;
  batsmen[0].target = batsmen[0].base = BATSMAN1_START.x;
  batsmen[1].target = batsmen[1].base = BATSMAN2_START.x;
  resetBall();
  fielders = [
    {x: 330, y: 120, homeX: 330, homeY: 120},
    {x: 330, y: 320, homeX: 330, homeY: 320},
    {x: 600, y: 170, homeX: 600, homeY: 170},
    {x: 600, y: 270, homeX: 600, homeY: 270}
  ];
  fielder = null;
  fielderHasBall = false;
  fielderThrowing = false;
  returningToBowler = false;
  updateScore();
  cancelAnimationFrame(animFrame);
  draw();
}

function resetBall() {
  ball = {
    x: BALL_START_X,
    y: BALL_START_Y,
    vx: 6,
    vy: 0,
    radius: BALL_RADIUS,
    hit: false,
    inPlay: false,
    outcome: '',
    progress: 0
  };
  ballMoving = true;
  ballHit = false;
  ballOutcome = '';
  running = false;
  runCount = 0;
  batsmen[0].x = BATSMAN1_START.x;
  batsmen[1].x = BATSMAN2_START.x;
  batsmen[0].target = batsmen[0].base = BATSMAN1_START.x;
  batsmen[1].target = batsmen[1].base = BATSMAN2_START.x;
  lastCross = false;
  returningToBowler = false;
}

function updateScore() {
  scoreInfo.textContent = "Score: " + score;
}

function drawStumps(x, y) {
  ctx.save();
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 3;
  for(let i=0;i<3;i++) {
    ctx.beginPath();
    ctx.moveTo(x+i*STUMP_GAP, y-STUMP_HEIGHT/2);
    ctx.lineTo(x+i*STUMP_GAP, y+STUMP_HEIGHT/2);
    ctx.stroke();
  }
  ctx.restore();
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.fillStyle = "#f3eaae";
  ctx.fillRect(PITCH_X1, PITCH_Y, PITCH_X2-PITCH_X1, PITCH_H);
  ctx.restore();
  drawStumps(WICKET1_X, WICKET1_Y);
  drawStumps(WICKET2_X, WICKET2_Y);
  for(const fld of fielders) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(fld.x, fld.y, 16, 0, Math.PI*2);
    ctx.fillStyle = "#0af";
    ctx.fill();
    ctx.beginPath();
    ctx.arc(fld.x, fld.y-13, 6, 0, Math.PI*2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.restore();
  }
  for(const b of batsmen) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(b.x, b.y-18, 10, 0, Math.PI*2);
    ctx.fillStyle = "#ffe100";
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(b.x, b.y-8);
    ctx.lineTo(b.x, b.y+18);
    ctx.stroke();
    ctx.restore();
  }
  ctx.save();
  ctx.translate(BAT_X, BAT_Y);
  ctx.rotate(batAngle);
  ctx.fillStyle = "#ebc154";
  ctx.fillRect(-BAT_W/2, -BAT_H, BAT_W, BAT_H);
  ctx.restore();
  ctx.save();
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, 2 * Math.PI);
  ctx.fillStyle = ball.hit ? "#9f0" : "#f11";
  ctx.fill();
  ctx.restore();
  if (fielderThrowing) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(fieldBallX, fieldBallY, BALL_RADIUS, 0, 2*Math.PI);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.restore();
  }
  if (running) {
    ctx.save();
    ctx.font = "bold 22px Segoe UI";
    ctx.fillStyle = "#ffe100";
    ctx.fillText("RUNNING...", 370, 55);
    ctx.restore();
  }
  if (ballMoving) update();
  animFrame = requestAnimationFrame(draw);
}

function swingBat() {
  if (swinging || ball.hit) return;
  swinging = true;
  swingFrame = 0;
  function animateSwing() {
    swingFrame++;
    if (swingFrame <= 7) {
      batAngle = -Math.PI/2 * Math.sin(Math.PI * swingFrame / 14);
      requestAnimationFrame(animateSwing);
    } else {
      batAngle = 0;
      swinging = false;
    }
  }
  animateSwing();
}

function update() {
  let prevX = ball.x, prevY = ball.y;
  if (!ball.hit) {
    ball.x += ball.vx;
    ball.y += ball.vy;
    if (batCollide(prevX, prevY, ball.x, ball.y) && swinging) {
      ball.hit = true;
      let timing = Math.abs(ball.y - BAT_Y);
      let rand = Math.random();
      if (timing < 16 && rand > 0.65) {
        ball.outcome = "6";
        ballOutcome = "SIX!";
        ball.vx = 13; ball.vy = (Math.random()-0.5)*2;
        ball.progress = 0;
      } else if (timing < 24 && rand > 0.3) {
        ball.outcome = "4";
        ballOutcome = "FOUR!";
        ball.vx = 9; ball.vy = (Math.random()-0.5)*5;
        ball.progress = 0;
      } else if (timing < 34) {
        ball.outcome = "run";
        ballOutcome = "Run!";
        ball.vx = 6; ball.vy = (Math.random()-0.5)*8;
        ball.progress = 0;
      } else {
        ball.outcome = "caught";
        ballOutcome = "Caught!";
        ball.vx = 6; ball.vy = -10;
      }
    }
    if (ball.x > BAT_X+30 && !ball.hit) {
      ballMoving = false;
      setTimeout(resetBall, 1200);
    }
  } else {
    if (ball.outcome == "6") {
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.progress += Math.abs(ball.vx);
      if (outOfBounds(ball.x, ball.y) || ball.progress > 650) {
        returningToBowler = true;
        ballMoving = false;
        setTimeout(() => {returnToBowler();}, 700);
      }
    } else if (ball.outcome == "4") {
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.progress += Math.abs(ball.vx);
      if (outOfBounds(ball.x, ball.y) || ball.progress > 540) {
        returningToBowler = true;
        ballMoving = false;
        setTimeout(() => {returnToBowler();}, 700);
      }
    } else if (ball.outcome == "run") {
      if (!fielder) {
        let minDist = 9999;
        for (const f of fielders) {
          let d = Math.abs(f.x - ball.x) + Math.abs(f.y - ball.y);
          if (d < minDist) { minDist = d; fielder = f; }
        }
        fielderHasBall = false;
        fielderThrowing = false;
        fieldBallX = ball.x;
        fieldBallY = ball.y;
        running = true;
        runCount = 0;
        batsmen[0].target = batsmen[1].base;
        batsmen[1].target = batsmen[0].base;
        batsmen[0].base = batsmen[0].x;
        batsmen[1].base = batsmen[1].x;
        lastCross = false;
      }
      if (!fielderHasBall) {
        let dx = ball.x - fielder.x, dy = ball.y - fielder.y;
        let d = Math.sqrt(dx*dx + dy*dy);
        if (d > 3) {
          fielder.x += dx/d*3.5;
          fielder.y += dy/d*3.5;
        } else {
          fielderHasBall = true;
          fielderThrowing = true;
        }
        ball.vx *= 0.96;
        ball.vy *= 0.96;
        ball.x += ball.vx;
        ball.y += ball.vy;
      } else if (fielderThrowing) {
        let dx = WICKET2_X - fielder.x, dy = WICKET2_Y - fielder.y;
        let d = Math.sqrt(dx*dx + dy*dy);
        if (!fieldBallX) { fieldBallX = fielder.x; fieldBallY = fielder.y; }
        let tx = dx/d*19, ty = dy/d*19;
        fieldBallX += tx;
        fieldBallY += ty;
        if (Math.abs(fieldBallX-WICKET2_X)<8 && Math.abs(fieldBallY-WICKET2_Y)<8) {
          fielderThrowing = false;
          running = false;
          ballMoving = false;
          score += runCount;
          updateScore();
          setTimeout(resetBall, 800);
          for(const fld of fielders) {
            fld.x = fld.homeX;
            fld.y = fld.homeY;
          }
          returningToBowler = false;
          fielder = null;
        }
      }
      if (running) {
        let speed = 1.8;
        batsmen[0].x += Math.sign(batsmen[0].target - batsmen[0].x) * speed;
        batsmen[1].x += Math.sign(batsmen[1].target - batsmen[1].x) * speed;
        let crossing = (batsmen[0].x < batsmen[1].x+10);
        if (crossing && !lastCross) {
          runCount++;
          lastCross = true;
        }
        if (!crossing) lastCross = false;
        if (Math.abs(batsmen[0].x-batsmen[0].target)<3 && Math.abs(batsmen[1].x-batsmen[1].target)<3) {
          let tmp = batsmen[0].target;
          batsmen[0].target = batsmen[1].base;
          batsmen[1].target = batsmen[0].base;
          batsmen[0].base = batsmen[0].x;
          batsmen[1].base = batsmen[1].x;
        }
      }
    } else if (ball.outcome == "caught") {
      ball.y += ball.vy;
      ball.vy += 2;
      if (ball.y > 410) {
        returningToBowler = true;
        ballMoving = false;
        setTimeout(() => {returnToBowler();}, 900);
      }
    }
    if (!returningToBowler && outOfBounds(ball.x, ball.y) && ball.outcome !== "run") {
      returningToBowler = true;
      ballMoving = false;
      setTimeout(() => {returnToBowler();}, 700);
    }
  }
}

function outOfBounds(x, y) {
  return (x < FIELD_LEFT || x > FIELD_RIGHT || y < FIELD_TOP || y > FIELD_BOTTOM);
}

function returnToBowler() {
  ballMoving = false;
  returningToBowler = false;
  setTimeout(resetBall, 500);
  for(const fld of fielders) {
    fld.x = fld.homeX;
    fld.y = fld.homeY;
  }
  fielder = null;
}

function batCollide(px, py, x, y) {
  let bx1 = BAT_X, by1 = BAT_Y;
  let bx2 = BAT_X + Math.sin(batAngle)*(-BAT_H), by2 = BAT_Y - Math.cos(batAngle)*BAT_H;
  let steps = Math.ceil(Math.hypot(x-px, y-py)/2);
  for (let i=0; i<=steps; ++i) {
    let bx = px + (x-px)*i/steps;
    let by = py + (y-py)*i/steps;
    let d = pointToSegmentDist(bx,by, bx1,by1, bx2,by2);
    if (d < BALL_RADIUS + BAT_W/2) return true;
  }
  return false;
}
function pointToSegmentDist(px,py, x1,y1, x2,y2) {
  let A = px - x1;
  let B = py - y1;
  let C = x2 - x1;
  let D = y2 - y1;
  let dot = A * C + B * D;
  let len_sq = C * C + D * D;
  let param = -1;
  if (len_sq !== 0) param = dot / len_sq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  let dx = px - xx;
  let dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

canvas.addEventListener("click", swingBat);
window.addEventListener("keydown", e => { if (e.code === "Space") swingBat(); });
resetGame();
  </script>
</body>
</html>
